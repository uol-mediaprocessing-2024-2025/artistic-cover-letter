import numpy
from fastapi import FastAPI, UploadFile, File, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse
from image_processing import process_image_blur
from PIL import Image,ImageDraw,ImageFont
import io
import uvicorn
import cv2
import numpy as np
from old import Font
from old import Letter
from old import LetterText
from old import blend_images
from matplotlib import pyplot as plt

app = FastAPI()

# CORS middleware configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins (adjust for production use)
    allow_credentials=True,
    allow_methods=["*"],  # Allows all HTTP methods
    allow_headers=["*"],  # Allows all headers
)


@app.post("/apply-blur")
async def apply_blur(file: UploadFile = File(...)):
    """
    API endpoint to apply a blur effect to an uploaded image.
    :param file: The uploaded image file.
    :return: StreamingResponse containing the blurred image.
    """
    try:
        # Process the image
        blurred_image = await process_image_blur(file)

        # Create a BytesIO object to send the image as a stream
        image_io = io.BytesIO()
        blurred_image.save(image_io, format="PNG")
        image_io.seek(0)

        # Return the blurred image as a stream in the response
        return StreamingResponse(image_io, media_type="image/png")
    except Exception as e:
        return JSONResponse(
            status_code=500,
            content={"message": "Failed to process image", "error": str(e)},
        )
@app.post("/submit-text")
async def submit_text(request: Request):
    text = await request.json();
    print(f"Received text: {text}")

    # More optimal Text mask code generated by Bing AI
    # Define the text and font
    font_path = r'C:\Users\System-Pc\Desktop\impact.ttf'
    font_size = 140 #70 is roughly equivalent to 72 pt on 300 DPI A4 paper, tested in Photoshop
    font = ImageFont.truetype(font_path, font_size)

    # Create a temporary image to get the size of the text
    temp_image = Image.new('RGBA', (1, 1), (0, 0, 0, 0))
    draw = ImageDraw.Draw(temp_image)
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_width = text_bbox[2] - text_bbox[0]
    text_height = text_bbox[3] - text_bbox[1]

    # Get font metrics for additional padding to avoid text cutoff
    ascent, descent = font.getmetrics()
    padding = descent + 10  # Add descent and some extra padding

    # Create the final image with the size adjusted for padding
    image_width = text_width + padding * 2
    image_height = text_height + padding * 2
    image = Image.new('RGBA', (image_width, image_height), (0, 0, 0, 255))
    draw = ImageDraw.Draw(image)

    # Draw the text on the image with padding
    draw.text((padding, padding - descent), text, font=font, fill="white", align="left")
    dilated = cv2.dilate(np.array(image), np.ones((5, 5), np.uint8), iterations=1)
    image2 = Image.fromarray(dilated)

    image_io = io.BytesIO()
    image2.save(image_io, format="PNG")
    image_io.seek(0)
    return StreamingResponse(image_io, media_type="image/png")

@app.post("/dropshadow")
async def dropshadow(request: Request):
    info = await request.json()
    text = info["text"]
    radius = int(info['radius'])
    intensity = int(info['intensity'])/100
    resolution = int(info['resolution'])
    if radius > 100:
        print(f"dropshadow limited to 100 units radius")
        radius = 100
    if radius < 1:
        radius = 1
    if resolution > 2400:
        resolution = 2400
    if resolution < 1:
        resolution = 1
    radius = radius*resolution/300
    radius = round(radius)
    print(f"Received dropshadow: {radius}")

    # More optimal Text mask code generated by Bing AI
    # Define the text and font
    font_path = r'C:\Users\System-Pc\Desktop\impact.ttf'
    font_size = resolution #70 is equivalent to 72 pt on 300 DPI paper
    font = ImageFont.truetype(font_path, font_size)

    # Create a temporary image to get the size of the text
    temp_image = Image.new('RGBA', (1, 1), (0, 0, 0, 0))
    draw = ImageDraw.Draw(temp_image)
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_width = text_bbox[2] - text_bbox[0]
    text_height = text_bbox[3] - text_bbox[1]

    # Get font metrics for additional padding to avoid text cutoff
    ascent, descent = font.getmetrics()
    padding = descent + 10  # Add descent and some extra padding

    # Create the final image with the size adjusted for padding
    image_width = text_width + padding * 2
    image_height = text_height + padding * 2
    image = Image.new('RGBA', (image_width, image_height), (0, 0, 0, 0))
    draw = ImageDraw.Draw(image)

    # Draw the text on the image with padding
    draw.text((padding, padding - descent), text, font=font, fill="white", align="left")

    # Handle dropshadow with Alpha channel and set all other channels to black
    r, g, b, a = image.split()
    dilated = cv2.dilate(np.array(a), circular_kernel(radius), iterations=1)
    blurred = cv2.GaussianBlur(dilated, (radius*4+1, radius*4+1), 0)
    dimmed = np.clip(blurred * intensity, 0, 255).astype(np.uint8)
    red = np.array(r)
    red[:] = 0
    green = np.array(g)
    green[:] = 0
    blue = np.array(b)
    blue[:] = 0
    dropshadow = Image.merge("RGBA", (Image.fromarray(red), Image.fromarray(green), Image.fromarray(blue), Image.fromarray(dimmed)))

    combined = Image.alpha_composite(dropshadow, image)

    image_io = io.BytesIO()
    combined.save(image_io, format="PNG")
    image_io.seek(0)

    return StreamingResponse(image_io, media_type="image/png")


def circular_kernel(radius):
    # Create a square grid of size (2*radius+1) x (2*radius+1)
    size = 2 * radius + 1
    kernel = np.zeros((size, size), dtype=np.uint8)

    # Calculate the center of the kernel
    center = radius

    # Fill the kernel with a circular pattern
    for i in range(size):
        for j in range(size):
            if np.sqrt((i - center) ** 2 + (j - center) ** 2) <= radius:
                kernel[int(i), int(j)] = 1

    return kernel

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
